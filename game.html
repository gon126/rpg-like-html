<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Souls-Like Box RPG</title>
<style>
    body { margin:0; background:#000; overflow:hidden; }
    #gameWindow { position:absolute; left:50%; top:50%; width:980px; height:600px; transform:translate(-50%,-50%); border:4px solid #444; background:#111; }
    #ui { position:absolute; top:10px; left:10px; color:#fff; font-family:monospace; font-size:18px; z-index:5; text-shadow:2px 2px 2px black; }
    #hint { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); color:#fff; font-family:monospace; font-size:20px; text-shadow:1px 1px 2px black; }
    #levelUpPopup, #pauseScreen {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 700px;
        background: rgba(0, 0, 0, 0.95);
        border: 4px solid #fff;
        padding: 20px;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        z-index: 10;
        text-align: center;
        color: #fff;
        font-family: monospace;
        display: none; /* Ensure levelUpPopup is hidden until triggered */
    }
    #pauseScreen { display: none; } /* Initially hidden */
    .upgrade-option {
        width: 200px;
        height: 150px;
        margin: 10px;
        padding: 10px;
        display: inline-block;
        border: 2px solid;
        cursor: pointer;
        transition: transform 0.1s;
        text-align: left;
    }
    .upgrade-option:hover {
        transform: scale(1.05);
    }
    .tier-1 { border-color: #808080; } /* Grey */
    .tier-2 { border-color: #00ff00; } /* Green */
    .tier-3 { border-color: #0000ff; } /* Blue */
    .tier-4 { border-color: #800080; } /* Purple */
    .tier-5 { border-color: #ff0000; } /* Red */
    .upgrade-name { font-size: 1.2em; font-weight: bold; margin-bottom: 5px; }
    .upgrade-desc { font-size: 0.9em; }
    .tier-label { font-size: 0.8em; margin-top: 5px; display: block; }
</style>
</head>
<body>
<div id="ui">HP: <span id="hp"></span> | Round: <span id="round"></span> | XP: <span id="xp"></span> | Level: <span id="level"></span> | Class: <span id="class"></span></div>
<div id="hint">Press Space to shoot | Press P to Pause</div>
<canvas id="gameWindow" width="980" height="600"></canvas>

<div id="levelUpPopup">
    <h2>Level Up! Choose an Upgrade</h2>
    <div id="upgradeOptionsContainer">
        </div>
</div>

<div id="pauseScreen">
    <h2>PAUSED</h2>
    <p>Press 'P' or 'Escape' to resume.</p>
</div>

<script>
// CANVAS
const canvas = document.getElementById("gameWindow");
const ctx = canvas.getContext("2d");
let keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// --- GAME CONSTANTS ---
const CRIT_CHANCE = 0.05; // 5% base chance
const CRIT_MULTIPLIER = 2; // 2x base damage
const EPSILON = 0.0001; // Epsilon constant to handle floating point errors in HP comparisons
const MAX_PIERCING_BUFF = 8; // Absolute maximum for piercing hits
const SUMMONER_SENTINEL_CHANCE = 0.10; // 10% chance to spawn a sentinel on enemy kill

// --- AUDIO SYSTEM ---
let backgroundMusic = new Audio('rat-dance-music.mp3');
backgroundMusic.loop = true;
backgroundMusic.volume = 0.4; 

let playerHurtSound = new Audio('ack.mp3'); 
let enemyHurtSound = new Audio('smash-desk.mp3'); 
let shootSound = new Audio('shoot.mp3'); 
// NOTE: For the level-up sound, a new file (e.g., 'levelup.mp3') would be ideal.

function playSound(audioElement, volume = 1.0) {
    if (!audioStarted) return; 
    audioElement.pause();
    audioElement.currentTime = 0;
    audioElement.volume = volume;
    audioElement.play().catch(e => console.log("Audio play error:", e));
}
// --------------------

// --- PAUSE TOGGLE ---
let paused = false; 
let audioStarted = false;

function togglePause() {
    paused = !paused;
    document.getElementById("pauseScreen").style.display = paused ? 'block' : 'none';
    if (paused) {
        backgroundMusic.pause();
    } else {
        if (audioStarted) backgroundMusic.play().catch(e => {}); 
        requestAnimationFrame(loop); 
    }
}

document.addEventListener("keydown", e => {
    if ((e.key.toLowerCase() === 'p' || e.key === 'escape') && !gameOver && document.getElementById("levelUpPopup").style.display !== 'block') {
        togglePause();
    }
});

function handleFirstInteraction() {
    if (!audioStarted) {
        backgroundMusic.play().catch(e => console.log("Background music error:", e));
        audioStarted = true;
        document.removeEventListener('keydown', handleFirstInteraction);
        document.removeEventListener('click', handleFirstInteraction);
    }
}
document.addEventListener('keydown', handleFirstInteraction, {once: true});
document.addEventListener('click', handleFirstInteraction, {once: true}); 
// --------------------

// URL params
const urlParams = new URLSearchParams(window.location.search);
const birthdayMode = urlParams.get("birthday") === "true";
const difficulty = urlParams.get("difficulty") || "medium";
const playerName = (urlParams.get("name") || "").toLowerCase();
const playerClass = urlParams.get("class") || "Ranger"; 

// Hardcore status
const hardcoreNames = ["eliad ben ilay", "nehorai"];
const hardcoreMode = hardcoreNames.includes(playerName) || urlParams.get("hardcore") === "true";

// Difficulty settings
let enemySpeedFactor = 1;
let enemyHpFactor = 1;
let spawnCount = 3;

switch(difficulty){
    case "easy": enemySpeedFactor=0.8; enemyHpFactor=0.8; break;
    case "medium": enemySpeedFactor=1; enemyHpFactor=1; break; 
    case "hard": enemySpeedFactor=1.3; enemyHpFactor=1.2; break;
}

// Player Class Base Stats
function getClassStats(className) {
    let stats = {
        movementSpeed: 4,
        damage: 25, 
        regen: 0, 
        bulletSpeed: 100,
        shootCooldown: 15, 
        maxHp: 100,
        piercingHits: 1, 
        critChanceBonus: 0, 
        critMultiplier: CRIT_MULTIPLIER, 
        bulletSizeMultiplier: 1.0, // NEW
        explosiveChance: 0.0,      // NEW
        instaKillChance: 0.0,      // NEW
        hasDashAbility: (className === "Revenant"), // NEW: True only for Revenant by default
    };

    switch(className) {
        case "Gunner": stats.damage = 18; stats.shootCooldown = 5; stats.bulletSpeed = 120; break;
        case "Brawler": stats.damage = 40; stats.movementSpeed = 3; stats.maxHp = 120; stats.shootCooldown = 20; break;
        case "Acolyte": stats.damage = 21; stats.regen = 0.1 / 60; stats.maxHp = 110; break;
        case "Sniper": stats.damage = 55; stats.shootCooldown = 40; stats.bulletSpeed = 180; break;
        case "Scout": stats.movementSpeed = 6; stats.damage = 18; stats.shootCooldown = 12; break;
        case "Engineer": stats.damage = 13; stats.shootCooldown = 4; stats.bulletSpeed = 90; break;
        case "Templar": stats.maxHp = 150; stats.movementSpeed = 3.5; stats.damage = 30; stats.shootCooldown = 25; break;
        case "Ranger": break; // Balanced (default)
        case "Berserker": stats.damage = 65; stats.shootCooldown = 60; stats.maxHp = 90; break;
        case "Warlock": stats.damage = 25; stats.regen = 0.2 / 60; stats.shootCooldown = 18; break;
        
        // NEW CLASSES
        case "Summoner": stats.maxHp = 120; stats.movementSpeed = 3.5; stats.damage = 15; stats.shootCooldown = 10; stats.regen = 0.1 / 60; break; 
        case "Paladin": stats.maxHp = 140; stats.movementSpeed = 3.0; stats.damage = 25; stats.shootCooldown = 15; stats.regen = 0.3 / 60; break;
        case "Revenant": stats.maxHp = 80; stats.movementSpeed = 5.5; stats.damage = 50; stats.shootCooldown = 8; stats.regen = 0; break; 
    }
    
    stats.bulletSpeed = stats.bulletSpeed > 0 ? stats.bulletSpeed : 10;
    stats.shootCooldown = Math.max(1, stats.shootCooldown);

    if(hardcoreMode){
        stats.damage *= 0.25; 
        stats.maxHp = 50;
        stats.movementSpeed *= 1.2; 
        stats.shootCooldown = Math.max(2, stats.shootCooldown / 2); 
    }

    return stats;
}

// PLAYER STATS AND STATE
const player = {x:450, y:300, w:48, h:48, speed:4, hp:100, shootCooldown:0, hitEffectFrames: 0, isDashing: false, dashCooldown: 0}; 
let bullets = [];
let enemies = [];
let bosses = [];
let round = 1;
let gameOver = false;
let playerXP = 0;
let playerLevel = 1;
let playerUpgrades = []; 
let damageTexts = []; 
let sentinels = []; 

let playerStats = getClassStats(playerClass);
player.hp = playerStats.maxHp;


function getXPNeeded(level, prestigeFactor = 1){
    return Math.round((level * 5) + (level**2 * 1.5)) * prestigeFactor;
}

function gainXP(amount, enemyX, enemyY){
    playerXP += amount;
    
    // NEW: SUMMONER SENTINEL LOGIC
    if (playerClass === "Summoner" && Math.random() < SUMMONER_SENTINEL_CHANCE) {
        sentinels.push({ 
            x: enemyX, 
            y: enemyY, 
            w: 30, 
            h: 30 
        });
        // Limit number of sentinels to keep performance good
        if (sentinels.length > 10) { 
            sentinels.shift(); 
        }
    }

    let xpNeeded = getXPNeeded(playerLevel);
    while(playerXP >= xpNeeded){
        playerXP -= xpNeeded;
        playerLevel++;
        showLevelUpPopup();
        xpNeeded = getXPNeeded(playerLevel); 
    }
}

// --- BOSS EFFECT DEFINITIONS (20 Unique Abilities with new mechanics) ---
const BOSS_EFFECTS = {
    // TIER 1 (R5)
    "Temporal Echo Shift": { desc: "+10% Multiplicative Cooldown Reduction (Faster Fire Rate).", effect: () => { playerStats.shootCooldown = Math.max(1, Math.round(playerStats.shootCooldown * 0.9)); } },
    "Gravimetric Implosion": { desc: "+1 Max Piercing Hits (Increased AoE Potential).", effect: () => { playerStats.piercingHits = Math.min(MAX_PIERCING_BUFF, playerStats.piercingHits + 1); } },
    "Life-Link Symbiosis": { desc: "+100 Max HP & +3% Lifesteal.", effect: () => { playerStats.maxHp += 100; addLifesteal(0.03, "Life-Link Symbiosis"); } },
    "Aetherial Sealing": { desc: "+10% Crit Chance & +10 Damage.", effect: () => { playerStats.critChanceBonus = (playerStats.critChanceBonus || 0) + 0.1; playerStats.damage += 10; } },
    "Arcane Expansion": { desc: "+25% Bullet Size (Larger Projectiles, easier to hit).", effect: () => { playerStats.bulletSizeMultiplier *= 1.25; } }, // NEW
    // TIER 2 (R10)
    "Phantasmal Replication": { desc: "-4 Frames Cooldown (Very Fast Attack Speed).", effect: () => { playerStats.shootCooldown = Math.max(1, playerStats.shootCooldown - 4); } },
    "Toxic Metabolism": { desc: "Massive +35 Damage.", effect: () => { playerStats.damage += 35; } },
    "Thermal Detonator": { desc: "5% Chance for shots to Explode on hit (50% AoE Damage).", effect: () => { playerStats.explosiveChance = (playerStats.explosiveChance || 0) + 0.05; } }, // NEW
    "Runic Transference": { desc: "Huge +45 Damage.", effect: () => { playerStats.damage += 45; } },
    "Aura of Dread": { desc: "+20% Crit Chance & Crit Multiplier increases to 2.2x.", effect: () => { playerStats.critChanceBonus = (playerStats.critChanceBonus || 0) + 0.2; playerStats.critMultiplier = 2.2; } },
    // TIER 3 (R15)
    "Shadow Step": { desc: "Gain the Dash ability (Press C/Shift for instant evasion).", effect: () => { playerStats.hasDashAbility = true; } }, // NEW
    "Singularity Dash": { desc: "+2.5 Movement Speed & +25 Max HP.", effect: () => { playerStats.movementSpeed += 2.5; playerStats.maxHp += 25; } },
    "Forced Fatigue": { desc: "+15 Damage & -3 Frames Cooldown.", effect: () => { playerStats.damage += 15; playerStats.shootCooldown = Math.max(1, playerStats.shootCooldown - 3); } },
    "Unraveling Strike": { desc: "+1 Max Piercing Hits & +10 Damage.", effect: () => { playerStats.piercingHits = Math.min(MAX_PIERCING_BUFF, playerStats.piercingHits + 1); playerStats.damage += 10; } },
    "Soul Bind": { desc: "+0.25 HP/sec Regen & +50 Max HP.", effect: () => { playerStats.regen += 0.25 / 60; playerStats.maxHp += 50; } },
    // TIER 4 (R20+)
    "Elemental Convergence": { desc: "Huge +50 Damage & +5% Crit Chance.", effect: () => { playerStats.damage += 50; playerStats.critChanceBonus = (playerStats.critChanceBonus || 0) + 0.05; } },
    "Reality Anchor": { desc: "Ultimate +120 Max HP & Minor Regen.", effect: () => { playerStats.maxHp += 120; playerStats.regen += 0.05 / 60; } },
    "Chrono Stutter": { desc: "Major -6 Frames Cooldown (Ultra-fast attack speed).", effect: () => { playerStats.shootCooldown = Math.max(1, playerStats.shootCooldown - 6); } },
    "Resource Siphon": { desc: "Major +5% Lifesteal.", effect: () => { addLifesteal(0.05, "Resource Siphon"); } },
    "Void Fracture": { desc: "2% Chance for Instant Kill on non-boss enemies.", effect: () => { playerStats.instaKillChance = (playerStats.instaKillChance || 0) + 0.02; } }, // NEW
};

// Helper function for lifesteal logic
function addLifesteal(amount, name) {
    let lifestealUpgrade = playerUpgrades.find(u => u.type === "lifesteal"); 
    if (!lifestealUpgrade) {
        playerUpgrades.push({name: name + " (Lifesteal)", type: "lifesteal", value: amount, onHit: true});
    } else {
        lifestealUpgrade.value += amount;
    }
}


function applyBossEffect(boss) {
    const abilityName = boss.abilities[0]; 
    const effect = BOSS_EFFECTS[abilityName];

    if (effect) {
        effect.effect();
        
        // Add a visible entry to the player's upgrades list for the boss buff
        playerUpgrades.push({ name: abilityName + " (Boss Buff)", desc: effect.desc, tier: "Boss", color: "tier-5" });
        
        // Full Heal after boss defeat
        player.hp = playerStats.maxHp; 
        console.log(`Player gained permanent buff: ${abilityName}`);
    }
}
// -----------------------------


// UPGRADE DEFINITIONS (Level-up upgrades - NO CHANGES TO THESE)
const UPGRADES = [
    // Tier 1 (Grey)
    { name: "Slight Speed", desc: "+0.5 Movement Speed", tier: 1, color: "tier-1", effect: () => playerStats.movementSpeed += 0.5 },
    { name: "Small Might", desc: "+5 Damage", tier: 1, color: "tier-1", effect: () => playerStats.damage += 5 },
    { name: "Health Nudge", desc: "Slight HP Regen (0.05/sec)", tier: 1, color: "tier-1", effect: () => playerStats.regen += 0.05 / 60 },
    { name: "Fast Cooldown", desc: "-1 Frame Cooldown", tier: 1, color: "tier-1", effect: () => playerStats.shootCooldown = Math.max(1, playerStats.shootCooldown - 1) },

    // Tier 2 (Green)
    { name: "Swiftness", desc: "+1.0 Movement Speed", tier: 2, color: "tier-2", effect: () => playerStats.movementSpeed += 1.0 },
    { name: "Power Focus", desc: "+10 Damage", tier: 2, color: "tier-2", effect: () => playerStats.damage += 10 },
    { name: "Vitality Boost", desc: "+20 Max HP", tier: 2, color: "tier-2", effect: () => playerStats.maxHp += 20 },
    { name: "Quick Shots", desc: "-2 Frame Cooldown", tier: 2, color: "tier-2", effect: () => playerStats.shootCooldown = Math.max(1, playerStats.shootCooldown - 2) },

    // Tier 3 (Blue)
    { name: "Phantom Steps", desc: "+1.5 Movement Speed, +10 Bullet Speed", tier: 3, color: "tier-3", effect: () => { playerStats.movementSpeed += 1.5; playerStats.bulletSpeed += 10; } },
    { name: "Major Damage", desc: "+20 Damage", tier: 3, color: "tier-3", effect: () => playerStats.damage += 20 },
    { name: "Rapid Regen", desc: "Significant HP Regen (0.2/sec)", tier: 3, color: "tier-3", effect: () => playerStats.regen += 0.2 / 60 },
    { name: "Rapid Fire", desc: "-10% Cooldown (Multiplicative)", tier: 3, color: "tier-3", effect: () => playerStats.shootCooldown = Math.max(1, Math.round(playerStats.shootCooldown * 0.9)) },
    { name: "Max HP Boost", desc: "+50 Max HP", tier: 3, color: "tier-3", effect: () => playerStats.maxHp += 50 },

    // Tier 4 (Purple)
    { name: "Ethereal Form", desc: "+2.5 Movement Speed, +20 Bullet Speed", tier: 4, color: "tier-4", effect: () => { playerStats.movementSpeed += 2.5; playerStats.bulletSpeed += 20; } },
    { name: "Annihilator", desc: "+40 Damage", tier: 4, color: "tier-4", effect: () => playerStats.damage += 40 },
    { name: "Vampiric Touch", desc: "Damage grants minor healing (5% Lifesteal).", tier: 4, color: "tier-4", effect: () => addLifesteal(0.05, "Vampiric Touch") },
    { name: "Infinity Focus", desc: "Major Cooldown Reduction (-5 Frames)", tier: 4, color: "tier-4", effect: () => playerStats.shootCooldown = Math.max(1, playerStats.shootCooldown - 5) },
    { name: "Piercing Rounds", desc: "+1 Max Hits per bullet (Max: " + MAX_PIERCING_BUFF + " total)", tier: 4, color: "tier-4", effect: () => playerStats.piercingHits = Math.min(MAX_PIERCING_BUFF, playerStats.piercingHits + 1) },

    // Tier 5 (Red)
    { name: "Godspeed", desc: "+5.0 Movement Speed, +50 Bullet Speed", tier: 5, color: "tier-5", effect: () => { playerStats.movementSpeed += 5.0; playerStats.bulletSpeed += 50; } },
    { name: "Worldbreaker", desc: "+80 Damage", tier: 5, color: "tier-5", effect: () => playerStats.damage += 80 },
    { name: "Phoenix Core", desc: "Regen and Max HP Surge (+100 Max HP, +0.5/sec Regen)", tier: 5, color: "tier-5", effect: () => { playerStats.maxHp += 100; playerStats.regen += 0.5 / 60; } },
    { name: "Temporal Rift", desc: "Instantaneous shooting (1 Frame Cooldown).", tier: 5, color: "tier-5", effect: () => playerStats.shootCooldown = 1 },
];

const TIER_CHANCES = [
    { level: 1,  chances: { 1: 70, 2: 20, 3: 8, 4: 2, 5: 0 } },
    { level: 4,  chances: { 1: 50, 2: 30, 3: 15, 4: 5, 5: 0 } },
    { level: 8,  chances: { 1: 35, 2: 35, 3: 20, 4: 8, 5: 2 } },
    { level: 13, chances: { 1: 20, 2: 35, 3: 30, 4: 12, 5: 3 } },
    { level: 21, chances: { 1: 10, 2: 25, 3: 35, 4: 20, 5: 10 } }
];

function getUpgradeChances(level) {
    let activeChances = TIER_CHANCES[0].chances;
    for (const chance of TIER_CHANCES) {
        if (level >= chance.level) {
            activeChances = chance.chances;
        }
    }
    return activeChances;
}

function getRandomTier(level) {
    const chances = getUpgradeChances(level);
    let rand = Math.random() * 100;
    let cumulative = 0;
    for (let tier = 1; tier <= 5; tier++) {
        cumulative += chances[tier];
        if (rand < cumulative) {
            return tier;
        }
    }
    return 1; 
}

function selectUpgrade(upgrade) {
    paused = false;
    document.getElementById("levelUpPopup").style.display = 'none';

    upgrade.effect();
    playerUpgrades.push(upgrade);
    
    // Full heal
    player.hp = playerStats.maxHp; 
    
    if (audioStarted) backgroundMusic.play().catch(e => {}); 
    requestAnimationFrame(loop); 
}

function getThreeUniqueUpgrades() {
    const availableUpgrades = [...UPGRADES];
    const selectedUpgrades = new Set();
    const result = [];
    const level = playerLevel;

    const tiers = [getRandomTier(level), getRandomTier(level), getRandomTier(level)];

    for (const targetTier of tiers) {
        let tierPool = availableUpgrades.filter(u => u.tier === targetTier && !selectedUpgrades.has(u));
        
        // Ensure Piercing Rounds can't be offered after max hits are reached
        if(playerStats.piercingHits >= MAX_PIERCING_BUFF) {
             tierPool = tierPool.filter(u => u.name !== "Piercing Rounds");
        }

        if (tierPool.length === 0) {
            // Fallback to any available upgrade not already selected
            tierPool = availableUpgrades.filter(u => !selectedUpgrades.has(u));
            if(playerStats.piercingHits >= MAX_PIERCING_BUFF) {
                 tierPool = tierPool.filter(u => u.name !== "Piercing Rounds");
            }
        }

        if (tierPool.length > 0) {
            const randomIndex = Math.floor(Math.random() * tierPool.length);
            const upgrade = tierPool[randomIndex];
            result.push(upgrade);
            selectedUpgrades.add(upgrade);
        } else {
            break;
        }
    }

    return result;
}

function showLevelUpPopup() {
    paused = true;
    backgroundMusic.pause(); 
    // NEW: Ideally play a level-up sound here.

    const options = getThreeUniqueUpgrades();
    const container = document.getElementById("upgradeOptionsContainer");
    container.innerHTML = '';

    options.forEach(upgrade => {
        const optionDiv = document.createElement('div');
        optionDiv.className = `upgrade-option ${upgrade.color}`;
        optionDiv.innerHTML = `
            <span class="upgrade-name">${upgrade.name}</span>
            <span class="tier-label">Tier ${upgrade.tier}</span>
            <hr style="border-color: inherit; margin: 5px 0;">
            <span class="upgrade-desc">${upgrade.desc}</span>
        `;
        optionDiv.onclick = () => selectUpgrade(upgrade);
        container.appendChild(optionDiv);
    });

    document.getElementById("levelUpPopup").style.display = 'block';
}

// SPAWN ENEMIES
function startRound(){
    enemies = [];
    if(round % 5 === 0){ spawnBoss(); }
    
    const BASE_ENEMY_HP = 30;
    const SCALING_HP_PER_ROUND = 8;

    for(let i=0;i<spawnCount;i++){
        let x = Math.random() * (canvas.width-48);
        let y = Math.random() * (canvas.height-48);
        // Difficulty scaling is exponential for endless game.
        let enemyMaxHp = (BASE_ENEMY_HP + round * SCALING_HP_PER_ROUND) * enemyHpFactor * (1 + (round * 0.1));

        enemies.push({
            x:x, y:y, w:48, h:48,
            hp: enemyMaxHp,
            maxHp: enemyMaxHp, 
            speed: (1 + round*0.2)*enemySpeedFactor,
            hitEffectFrames: 0
        });
    }
    spawnCount += 2;
}

// SPAWN BOSS
function spawnBoss(){
    const BOSS_HP_MULTIPLIER = 1000;
    const BOSS_SPEED = 1;
    const BOSS_XP = 50;

    let bossHp = BOSS_HP_MULTIPLIER + round * 250;
    
    let boss = {
        x: canvas.width/2 - 64,
        y: 50,
        w: 128,
        h: 128,
        hp: bossHp,
        maxHp: bossHp,
        speed: BOSS_SPEED,
        abilities: generateBossAbilities(),
        xp: BOSS_XP, 
        alive: true,
        hitEffectFrames: 0
    };
    bosses.push(boss);
}

// Boss abilities list key:
// 1-5: R5
// 6-10: R10
// 11-15: R15
// 16-20: R20+
const BOSS_ABILITY_KEYS = Object.keys(BOSS_EFFECTS);

function generateBossAbilities() {
    // Select an ability based on current round tier
    let tierIndex = Math.floor(round / 5);
    let start, end;

    if (tierIndex === 1) { // R5 (Abilities 1-5)
        start = 0; end = 5;
    } else if (tierIndex === 2) { // R10 (Abilities 6-10)
        start = 5; end = 10;
    } else if (tierIndex === 3) { // R15 (Abilities 11-15)
        start = 10; end = 15;
    } else if (tierIndex >= 4) { // R20+ (Abilities 16-20, then cycles through all 20)
        start = 15; end = 20;
    } else { // Fallback (R5 is the first boss round)
        start = 0; end = 5;
    }

    let availableAbilities = BOSS_ABILITY_KEYS.slice(start, end);
    
    // For R25 and beyond, cycle through the full list of 20 abilities
    if (round >= 25) {
        availableAbilities = BOSS_ABILITY_KEYS;
    }

    let ability = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
    
    return [ability];
}

// SHOOT
function shoot(){
    if(player.shootCooldown>0 || gameOver || paused) return;
    
    // Calculate effective crit chance and multiplier
    const effectiveCritChance = CRIT_CHANCE + (playerStats.critChanceBonus || 0);
    
    // Apply size multiplier to base bullet dimensions
    let bulletW = 4 * playerStats.bulletSizeMultiplier; 
    let bulletH = 20 * playerStats.bulletSizeMultiplier; 
    let bulletSpeed = playerStats.bulletSpeed;
    let bulletY = player.y;
    let bulletX = player.x+player.w/2-bulletW/2;
    let bulletType = "default";

    // --- UNIQUE ATTACK MECHANICS ---
    if (playerClass === "Summoner") {
        bulletType = "orb";
        bulletSpeed = 70; // Slower orb
        bulletW = 10 * playerStats.bulletSizeMultiplier; // Apply size multiplier to base orb size
        bulletH = 10 * playerStats.bulletSizeMultiplier; // Apply size multiplier to base orb size
        bulletX = player.x + player.w/2 - bulletW/2;
    } else if (playerClass === "Revenant") {
        bulletType = "slash";
        bulletSpeed = 200; // Very fast melee wave/slash
        bulletW = 40 * playerStats.bulletSizeMultiplier; // Apply size multiplier to base slash size
        bulletH = 15 * playerStats.bulletSizeMultiplier; // Apply size multiplier to base slash size
        bulletX = player.x + player.w/2 - bulletW/2; 
        bulletY = player.y - bulletH;
    }
    // -----------------------------


    bullets.push({
        x: bulletX, 
        y: bulletY, 
        w: bulletW, 
        h: bulletH, 
        speed: bulletSpeed, 
        damage: playerStats.damage,
        isCrit: Math.random() < effectiveCritChance, 
        hitsLeft: playerStats.piercingHits,
        type: bulletType,
        isExplosive: Math.random() < playerStats.explosiveChance // NEW: for explosion logic
    }); 
    
    playSound(shootSound, 0.4); 
    
    player.shootCooldown = playerStats.shootCooldown; 
    document.getElementById("hint").style.display="none";
}

// UPDATE
function update(){
    if(gameOver || paused) return;

    // NEW: Update and fade damage texts
    damageTexts.forEach(t => {
        t.y -= 1; // Move up
        t.frames--; // Fade out counter
    });
    damageTexts = damageTexts.filter(t => t.frames > 0);

    // HP Regen
    player.hp = Math.min(playerStats.maxHp, player.hp + playerStats.regen);

    // --- DASH LOGIC (for Revenant and Shadow Step classes) ---
    if (playerStats.hasDashAbility) {
        if (player.dashCooldown > 0) {
            player.dashCooldown--;
        }
        
        // Dash activation (C or Shift key)
        if ( (keys["c"] || keys["shift"]) && player.dashCooldown === 0) {
            player.isDashing = true;
            player.dashCooldown = 60; // 1 second cooldown
        }
        
        // Dash movement is instant
        if (player.isDashing) {
            let dashSpeed = playerStats.movementSpeed * 5; // 5x speed boost
            
            // Movement during dash
            if(keys["w"]) player.y -= dashSpeed;
            if(keys["s"]) player.y += dashSpeed;
            if(keys["a"]) player.x -= dashSpeed;
            if(keys["d"]) player.x += dashSpeed;

            player.isDashing = false; // Dash is instant, only lasts for the duration of one update frame
        }
    }
    // ---------------------------------------------------------------------------------


    // Movement (Standard logic)
    // Only apply if not currently performing the Dash movement
    if(!player.isDashing) {
        if(keys["w"]) player.y -= playerStats.movementSpeed;
        if(keys["s"]) player.y += playerStats.movementSpeed;
        if(keys["a"]) player.x -= playerStats.movementSpeed;
        if(keys["d"]) player.x += playerStats.movementSpeed;
    }

    // Walls
    player.x = Math.max(0, Math.min(canvas.width-player.w, player.x));
    player.y = Math.max(0, Math.min(canvas.height-player.h, player.y));

    // Shooting
    if(keys[" "]) shoot();
    if(player.shootCooldown>0) player.shootCooldown--;

    // Bullets move
    bullets.forEach(b => b.y -= b.speed);
    bullets = bullets.filter(b => b.y > -20 && b.hitsLeft > 0);

    // Enemy movement
    enemies.forEach(e=>{
        let target = player;
        
        // Enemies prioritize the closest Sentinel if one is closer than the player
        if (playerClass === "Summoner" && sentinels.length > 0) {
            let closestSentinel = null;
            let minDistToSentinel = Infinity;

            sentinels.forEach(s => {
                let dist = Math.hypot(s.x - e.x, s.y - e.y);
                if (dist < minDistToSentinel) {
                    minDistToSentinel = dist;
                    closestSentinel = s;
                }
            });

            let distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
            
            // If the closest Sentinel is within 150px and closer than the player
            if (minDistToSentinel < 150 && minDistToSentinel < distToPlayer) {
                target = closestSentinel;
            }
        }
        
        let dx = target.x - e.x;
        let dy = target.y - e.y;
        let dist = Math.hypot(dx, dy);
        
        if(dist>0){
            e.x += (dx/dist)*e.speed;
            e.y += (dy/dist)*e.speed;
        }
        if(dist<40){ 
            let previousHP = player.hp;
            // Only take damage if not dashing (Revenant/Shadow Step provides brief invulnerability)
            if(!player.isDashing) { 
                player.hp -= hardcoreMode ? 2 : 0.2; 
            }
            if(player.hp < previousHP) {
                playSound(playerHurtSound, 0.7); 
                player.hitEffectFrames = 5; // NEW: Set player hit flash
            }
        }
    });

    // Bullet collisions with Enemies
    bullets.forEach(b=>{
        for(let e of enemies){
            if(b.hitsLeft > 0 && b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y){
                
                let actualDamage = b.damage;
                
                // Crit Check
                if (b.isCrit) {
                    actualDamage *= playerStats.critMultiplier;
                }

                // --- NEW: INSTA-KILL CHECK (Non-boss only) ---
                let isInstaKill = Math.random() < playerStats.instaKillChance;
                if (isInstaKill) {
                    actualDamage = e.hp; // Deal full current HP as damage
                    b.hitsLeft = 0; // Consume the bullet (no piercing/explosion)
                    damageTexts.push({ x: e.x + e.w/2, y: e.y + e.h/2 - 20, text: "VOID KILL", isCrit: true, frames: 60 });
                }
                // ---------------------------------------------

                // NEW: Record damage text
                damageTexts.push({ 
                    x: e.x + e.w/2, 
                    y: e.y + e.h/2, 
                    text: actualDamage.toFixed(0), 
                    isCrit: b.isCrit, 
                    frames: 30 
                });

                e.hp -= actualDamage; 
                e.hitEffectFrames = 5; 
                
                if (!isInstaKill) {
                    b.hitsLeft--; 
                }
                
                playSound(enemyHurtSound, 0.5); 
                
                // --- NEW: EXPLOSION LOGIC ---
                if (b.isExplosive && !isInstaKill) {
                    const explosionDamage = actualDamage * 0.5; // 50% damage in a small radius
                    const explosionRadius = 60;
                    
                    enemies.forEach(otherE => {
                        // Check distance from the primary target (e), not the projectile itself
                        if (otherE !== e) { 
                            let dist = Math.hypot((otherE.x + otherE.w/2) - (e.x + e.w/2), (otherE.y + otherE.h/2) - (e.y + e.h/2));
                            if (dist < explosionRadius) {
                                otherE.hp -= explosionDamage;
                                otherE.hitEffectFrames = 5;
                                // Record splash damage text
                                damageTexts.push({ 
                                    x: otherE.x + otherE.w/2, 
                                    y: otherE.y + otherE.h/2 + 10, 
                                    text: `(${explosionDamage.toFixed(0)})`, 
                                    isCrit: false, 
                                    frames: 30 
                                });
                            }
                        }
                    });
                }
                // -----------------------------

                // Lifesteal check
                const lifestealUpgrade = playerUpgrades.find(u => u.type === "lifesteal");
                if(lifestealUpgrade){
                    player.hp = Math.min(playerStats.maxHp, player.hp + actualDamage * lifestealUpgrade.value);
                }
            }
        }
    });

    // Enemy defeat
    let defeatedEnemies = enemies.filter(e=>e.hp <= EPSILON); 
    defeatedEnemies.forEach(e => gainXP(1, e.x, e.y)); 
    enemies = enemies.filter(e=>e.hp > EPSILON); 

    // Boss movement
    bosses.forEach(boss => {
        if(!boss.alive) return;
        let dx = player.x - boss.x;
        let dy = player.y - boss.y;
        let dist = Math.hypot(dx, dy);
        if(dist>0){ boss.x += (dx/dist)*boss.speed; boss.y += (dy/dist)*boss.speed; }
        if(dist<60){ 
            let previousHP = player.hp;
            if(!player.isDashing) {
                player.hp -= 1; 
            }
            if(player.hp < previousHP) {
                playSound(playerHurtSound, 0.7); 
                player.hitEffectFrames = 5; 
            }
        }
    });

    // Bullet hits boss (simplified logic, no explosion/insta-kill on bosses)
    bullets.forEach(b=>{
        for(let boss of bosses){
            if(!boss.alive) continue;
            if(b.hitsLeft > 0 && b.x < boss.x + boss.w && b.x + b.w > boss.x && b.y < boss.y + boss.h && b.y + b.h > boss.y){
                
                let actualDamage = b.isCrit ? b.damage * playerStats.critMultiplier : b.damage;
                
                // NEW: Record damage text
                damageTexts.push({ 
                    x: boss.x + boss.w/2, 
                    y: boss.y + boss.h/2, 
                    text: actualDamage.toFixed(0), 
                    isCrit: b.isCrit, 
                    frames: 30 
                });

                boss.hp -= actualDamage; 
                boss.hitEffectFrames = 5;

                b.hitsLeft--; 
                
                playSound(enemyHurtSound, 0.5); 
                
                // Lifesteal check
                const lifestealUpgrade = playerUpgrades.find(u => u.type === "lifesteal");
                if(lifestealUpgrade){
                    player.hp = Math.min(playerStats.maxHp, player.hp + actualDamage * lifestealUpgrade.value);
                }

                break; 
            }
        }
    });

    // Boss defeat
    bosses.forEach(boss=>{
        if(boss.hp <= EPSILON && boss.alive){ 
            boss.alive=false;
            gainXP(boss.xp);
            applyBossEffect(boss); 
        }
    });
    bosses = bosses.filter(b=>b.alive && b.hp > EPSILON); 

    // Next round (Endless loop)
    if(enemies.length===0 && bosses.length===0 && !gameOver){
        round++;
        startRound();
    }

    // HP clamp
    player.hp = Math.max(0, Math.min(playerStats.maxHp, player.hp));
    if(player.hp===0) {
        gameOver=true;
        backgroundMusic.pause(); 
    }
}

// DRAW
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // --- DRAW SENTINELS (Summoner Only) ---
    if (playerClass === "Summoner") {
        sentinels.forEach(s => {
            ctx.fillStyle = "#8888ff"; // Light Blue/Purple Sentinel
            ctx.fillRect(s.x, s.y, s.w, s.h);
            
            // Draw an attracting symbol
            ctx.fillStyle = "#000";
            ctx.font = "18px monospace";
            ctx.textAlign = "center";
            ctx.fillText("S", s.x + s.w / 2, s.y + s.h * 0.7);
        });
    }

    // player
    // NEW: Apply player hit flash effect
    if (player.hitEffectFrames > 0) {
        ctx.fillStyle = "#ff0000"; // Red Flash
        player.hitEffectFrames--;
    } else {
        ctx.fillStyle="#00eaff"; 
    }
    ctx.fillRect(player.x,player.y,player.w,player.h);
    
    // WEAPON DRAWING 
    const gunX = player.x + player.w - 12; 
    const gunY = player.y - 10;
    const gunW = 10;
    const gunH = 25;
    ctx.fillStyle="#333"; ctx.fillRect(gunX, gunY, gunW, gunH);
    ctx.strokeStyle="#ff0000"; ctx.lineWidth=2; ctx.strokeRect(gunX, gunY, gunW, gunH);
    ctx.fillStyle="#000"; ctx.fillRect(gunX + gunW/2 - 2, gunY + gunH - 8, 4, 8);

    // Cooldown Indicator on Weapon
    if(playerStats.shootCooldown > 1){
        const cooldownRatio = player.shootCooldown / playerStats.shootCooldown;
        const indicatorHeight = gunH * cooldownRatio;
        ctx.fillStyle = "rgba(255, 0, 0, 0.7)"; // Red indicator
        ctx.fillRect(gunX, gunY + gunH - indicatorHeight, gunW, indicatorHeight);
    }

    // Player Face
    ctx.fillStyle="#000"; ctx.beginPath();
    ctx.arc(player.x+12,player.y+18,4,0,Math.PI*2);
    ctx.arc(player.x+36,player.y+18,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(player.x+24,player.y+30,10,0,Math.PI);
    ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.stroke();

    if(birthdayMode){
        ctx.fillStyle="#ff0"; ctx.beginPath();
        ctx.moveTo(player.x+player.w/2,player.y-20);
        ctx.lineTo(player.x+player.w/2-10,player.y);
        ctx.lineTo(player.x+player.w/2+10,player.y); ctx.closePath();
        ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();
    }

    // Player Health Bar
    ctx.fillStyle="#555"; ctx.fillRect(player.x,player.y-10,player.w,6);
    ctx.fillStyle="#0f0"; ctx.fillRect(player.x,player.y-10,(player.hp/playerStats.maxHp)*player.w,6);
    ctx.strokeStyle="#000"; ctx.lineWidth=2; ctx.strokeRect(player.x,player.y-10,player.w,6);

    bullets.forEach(b=>{ 
        // Determine base color based on class or piercing/crit
        let baseColor = "yellow"; // Default
        if (playerStats.piercingHits > 1) baseColor = "#00ffff"; // Cyan Piercing
        if (b.isCrit) baseColor = "#ff8800"; // Orange Crit

        if (b.type === "orb") {
            ctx.fillStyle = b.isCrit ? "#ff00ff" : "#8a2be2"; // Purple orb (magenta if crit)
            ctx.beginPath();
            ctx.arc(b.x + b.w / 2, b.y + b.h / 2, b.w / 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (b.type === "slash") {
            ctx.fillStyle = b.isCrit ? "rgba(255, 0, 0, 0.9)" : "rgba(255, 255, 0, 0.7)"; // Red or Yellow Slash
            ctx.fillRect(b.x, b.y, b.w, b.h);
        } else {
            // Default draw (Ranger, Gunner, etc.)
            ctx.fillStyle = baseColor;
            ctx.fillRect(b.x,b.y,b.w,b.h); 
        }
    });

    enemies.forEach(e=>{
        // HIT FLASH EFFECT: White
        if (e.hitEffectFrames > 0) {
            ctx.fillStyle = "#fff"; 
            e.hitEffectFrames--;
        } else {
            ctx.fillStyle="#ff3b3b"; 
        }
        ctx.fillRect(e.x,e.y,e.w,e.h);
        
        // rest of enemy drawing 
        ctx.fillStyle="#000"; ctx.beginPath();
        ctx.moveTo(e.x+12,e.y+16); ctx.lineTo(e.x+20,e.y+20); ctx.lineTo(e.x+12,e.y+24); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(e.x+36,e.y+16); ctx.lineTo(e.x+28,e.y+20); ctx.lineTo(e.x+36,e.y+24); ctx.fill();
        ctx.beginPath(); ctx.moveTo(e.x+15,e.y+36); ctx.lineTo(e.x+33,e.y+28);
        ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.stroke();
        
        // Enemy Health Bar
        ctx.fillStyle="#555"; ctx.fillRect(e.x,e.y-6,e.w,4);
        ctx.fillStyle="#f00"; ctx.fillRect(e.x,e.y-6,(e.hp/e.maxHp)*e.w,4);
        ctx.strokeStyle="#000"; ctx.lineWidth=1; ctx.strokeRect(e.x,e.y-6,e.w,4);

        if(birthdayMode){
            ctx.fillStyle="#ff0"; ctx.beginPath();
            ctx.moveTo(e.x+e.w/2,e.y-20);
            ctx.lineTo(e.x+e.w/2-10,e.y);
            ctx.lineTo(e.x+e.w/2+10,e.y); ctx.closePath();
            ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();
        }
    });

    // Bosses
    bosses.forEach(boss=>{
        // HIT FLASH EFFECT: Yellow
        if (boss.hitEffectFrames > 0) {
            ctx.fillStyle = "#ffff00"; 
            boss.hitEffectFrames--;
        } else {
            ctx.fillStyle="#ff00ff"; 
        }
        ctx.fillRect(boss.x,boss.y,boss.w,boss.h);
        
        // rest of boss drawing 
        ctx.fillStyle="#555"; ctx.fillRect(boss.x, boss.y-10, boss.w, 8);
        ctx.fillStyle="#f0f"; ctx.fillRect(boss.x, boss.y-10, (boss.hp/boss.maxHp)*boss.w, 8);
        ctx.strokeStyle="#000"; ctx.lineWidth=2; ctx.strokeRect(boss.x, boss.y-10, boss.w, 8);
        ctx.fillStyle="#fff"; ctx.font="14px monospace";
        ctx.fillText("Ability: " + boss.abilities.join(", "), boss.x, boss.y + boss.h + 15);
    });

    // Floating Damage Numbers
    damageTexts.forEach(t => {
        ctx.fillStyle = t.isCrit ? "#ff8800" : "#fff"; // Orange for crit, white for normal
        ctx.font = t.isCrit ? "bold 16px monospace" : "14px monospace";
        ctx.globalAlpha = t.frames / 30; // Fades out
        ctx.textAlign = "center";
        ctx.fillText("-" + t.text, t.x, t.y);
        ctx.globalAlpha = 1.0; 
    });


    // UI Updates
    let currentHpRatio = player.hp / playerStats.maxHp;
    let hpElement = document.getElementById("hp");
    
    // HP Color Change Logic
    let hpColor = "#fff"; // White
    if (currentHpRatio < 0.25) {
        hpColor = "#ff0000"; // Red
    } else if (currentHpRatio < 0.5) {
        hpColor = "#ffff00"; // Yellow
    }
    hpElement.style.color = hpColor; // Apply color change to the span
    
    document.getElementById("hp").innerText=`${Math.floor(player.hp)} / ${playerStats.maxHp}`;
    document.getElementById("round").innerText=round;
    
    let xpNeeded = getXPNeeded(playerLevel);
    document.getElementById("xp").innerText=`${playerXP} / ${xpNeeded}`;
    document.getElementById("level").innerText=playerLevel;
    document.getElementById("class").innerText=playerClass;
    
    // Update hint with Dash if applicable
    let baseHint = "Press Space to shoot | Press P to Pause";
    if (playerStats.hasDashAbility) {
        let dashCooldownText = `(CD: ${Math.ceil(player.dashCooldown / 60)}s)`;
        baseHint += ` | Press C/Shift to Dash ${player.dashCooldown > 0 ? dashCooldownText : ''}`;
    }
    document.getElementById("hint").innerText = baseHint;


    if(gameOver){
        ctx.fillStyle="rgba(0,0,0,0.7)"; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="#f00"; ctx.font="60px monospace"; ctx.textAlign="center";
        ctx.fillText("GAME OVER",canvas.width/2,canvas.height/2);
        ctx.fillStyle="#fff"; ctx.font="24px monospace";
        ctx.fillText("Refresh to play again",canvas.width/2,canvas.height/2+50);
    }
}

// MAIN LOOP
function loop(){ 
    if(!paused){
        update(); 
        draw(); 
        requestAnimationFrame(loop); 
    }
}

// Initial setup
startRound();
loop();
</script>
</body>
</html>